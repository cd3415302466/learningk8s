[toc]

# 数据库

## 一. Mysql

 

### 1.存储方式和类型

**存储类型：**

MySQL属于关系型数据库，他的数据存放在二维表里面，MySQL的表和表之间的字段是存在上下级的关联的 。



**存储结构：**

关系型数据库对应的是结构化数据，需要预先定义表的结构，，结构定义了表的类型还有数据的存放形式，以及内容，所以后期修改较为麻烦。



**存储扩展：**

拓展困难，需要电脑性能的提升，所以一般都是纵向拓展



**版本过渡：**

MySQL：5.1 --> 5.5 --> 5.6 --> 5.7 -->8.0



**安全加固：**

运行脚本【早期5.6前】，当前为二进制程序

```
设置管理员root密码
禁止root远程登录
删除test数据库
删除anonymous用户账号
```



**查看mysql服务是否正常  :**[mysqladmin]

mysqladmin  -uroot  -pcentos ping

**正常返回提示：**

mysqld is alive



### 2. MySQL的DDL语句

**数据定义语言：**定义了不同的数据段，数据库、表、列、索引。

 常用语句关键词有，

- **create** 【创建】
- **dorp**【删除】
- **alter**【修改】

- **use**【进入数据库】
- **show**【显示当前当前有数据库和表】

- **desc**【查看表结构】



### 3. MySQL的DML语句

**数据操作语句：**用于添加、删除、更新、和查询数据库的记录，和数据库的完整性。

常用的关键字词有

- **insert** 【一次添加一行或多行数据】

- **delete**【删除数据，但不会缩减文件大小】

- **update**【修改、更新数据】

    



### 4. MySQL的DQL语句

**数据查询语句：**

- **select**【查询表的具体内容】







### 5 drop、delete和truncate的区别

- delete： 语句执行删除是每次从表中删除一行，并同时将删除的操作作为事务记录在日中文件中保存，以便需要时回滚【只是删除部分数据】
- truncate 是删除是把数据全部删除，并且不会同时把单独的操作记录写入到日志中，无法回滚【仅删除所有数据，不删除表】
- drop 是将表的所占空间全部释放掉【全部删除，包括框架】

- 想要删除部分数据使用delete，想要清空数据，且保留表的框架使用truncate，删除表数据和框架使用drop





### 5.多表查询方式

- **子查询：**【子查询仅能返回单个值】

```sql
SELECT Name,Age FROM students WHERE Age IN (SELECT Age FROM teachers);
```



- **联合查询【union】：**【列数要一致】【按列数合并】

```sql
select   name,tid from teachers union select name,teacherid from students;
```



- **交叉连接【cross join】：**【没用】

```sql
select * from students cross join teachers;
```



**内连接【inner join】:**【取交集】

```sql
select * from teachers inner join   select * from  students ;
```



- **左连接和右连接**

**左连接【left outer  join】:** 以左表为主根据条件查询右表数据﹐如果根据条件查询右表数据不存在使用null值填充

```sql
select s.teacherid,s.name,t.tid,t.name from  students s  left join teachers t on s.teacherid=t.tid;
```



- **右连接:** 以右表为主根据条件查询左表数据﹐如果根据条件查询左表数据不存在使用null值填充

```sql
select s.teacherid,s.name,t.tid,t.name from  students s  right  join teachers t on s.teacherid=t.tid;
```



- **完全外连接：**



- **自连接**



### 6. MySQL存储引擎 myisam和innodb

- **【5.5.5前MySQL默认】Myisam：**
    - **不支持事务**
    - **表级锁定**
    - **读写相互堵塞，无法同时读写**		
    - **只缓存索引**
    - **不支持外键约束、聚簇索引，以及MVCC【多版本并发控制机制】高并发**



- **【5.5.5后MySQL默认】innodb：**	
    - **行级锁**
    - **支持事务**
    - **读写阻塞和事务级别有关**
    - **可缓存数据和索引**
    - **支持聚簇索引、MVCC【多版本并发控制机制】高并发，以及全文索引**



- **MySQL中的myisam和innodb的区别**
    - InnoDB支持事务，而MyISAM不支持事务。
    - InnoDB支持行级锁，而MyISAM支持表级锁
    -  InnoDB支持MVCC，而MyISAM不支持
    -  InnoDB支持外键，而MyISAM不支持
    -  InnoDB不支持全文索引，而MyISAM支持





**其他的存储引擎：**



- **Performance_Schema:**
- **CSV：**
- **BLACKHOLE：**
- **example：**
- **BDB：**
- **Cluster/NDB：**
- **federated：**
- **archive：**
- **MPG_MYISAM：**
- **Memory：**







### 7. MySQL索引工作原理以及explain分析工具

官方定义：索引是排序的快速查找的特殊数据结构，定义作为查找条件的字段上，又称为键key，索引通过存储引擎实现

 

**索引类型分为**：

- 普通索引：基本索引，没有限制
- 唯一索引：索引列的值唯一，但是允许空值
- 主键索引：特殊的唯一索引，一张表里面只能有一个主键，不允许空值
- 复合索引：在多个字段上设置索引，只有在查询的时候使用创建时的第一个字段，索引才会触发，默认左前缀集合
- 全文索引：主要用来查询文本中的关键字 mysql的innodb不支持myisam支持





**B-Tree：**																																					

- B树有一个根节点，收索是从根节点开始的，每个节点是由关键字和记录以及指针组成， 如果查询的关键字和节点的关键字相等，那么就命中。如果没用命中就通过指针向分支节点查询，以此类推，直到找到命中的叶子节点，或者没有结果，返回



**mysql索引原理：**

**B+Tree：**

- B+Tree 也和B-Tree一样有根节点和分支节点以及叶子节点，但不同的是B+Tree的根节点和分支节点只存储数据的索引信息而不存储数据，B+tree的数据只存储在叶子分支，且叶子和相邻的叶子之间组成一个双向链表。查询的时候先从根节点开始匹配，到分支节点，最后到匹配的叶子节点，返回结果



**区别：**

-  B-Tree的分支节点关键字和记录是存放在一起的，而B+tree根节点和分支节点仅仅存放着索引，数据则存放在叶子节点



**索引优化：**

独立使用列，尽量避免参与运算

左前缀索引

多列索引



**索引管理：**

- **查询索引：**

```sql
show index from students;
desc   students
```



- **删除索引：**

```sql
DROP INDEX index_name ON tbl_name;
```



**explain：**

- **查询：**

```sql
explain  select  stuid  from students ;
```





### 8. MySQL 锁机制



- **锁类型：**	

    - **读锁：**共享锁【s 锁】 可读不可写；

    - **写锁：**独占锁【x锁】只可自己读、写；

        

- **锁力度：**
    - 表级锁【Mylsam】
    - 行级锁【innodb】



- **实现：**
    - 存储引擎
    - 服务器





加锁：

```SQL
lock  table  TA_NAME   lock_type

#READ ：读锁
#WRITE: 写锁
```



解锁：

```SQL
flush  table  TA_NAME   lock_type

#READ ：读锁
#WRITE: 写锁
```



###  9. MySQL的ACID特性

**ACID特性：**

**A：atomicity 原子性：**整个事务中的所有操作要么全部成功执行，要么全部失败后回滚

**C：consistency一致性：**数据库总是从一个一致性状态转换为另一个一致性状态,类似于能量守恒定
律

**I：Isolation隔离性：**一个事务所做出的操作在提交之前，是不能为其它事务所见；隔离有多种隔离
级别，实现并发

**D：durability持久性：**一旦事务提交，其所做的修改会永久保存于数据库中  



### 10. MySQL管理事务

**显示自动事务：**

```sql
BEGIN
BEGIN WORK
START TRANSACTION
```



**结束事务：**

```sql
#提交,相当于vi中的wq保存退出
COMMIT

#回滚,相当于vi中的q!不保存退出
ROLLBACK
```



**自动提交【只有DML语句支持】：**

```sql
set autocommit={1|0}
```



**查看正在进行的事务：**

```sql
SELECT * FROM information_schema.INNODB_TRX\G
```





### 11. MySQL事务隔离级别



| 隔离级别 | 脏读     | 不可重复读 | 幻读     | 加读锁 |
| -------- | -------- | ---------- | -------- | ------ |
| 读未提交 | 可以出现 | 可以出现   | 可以出现 | 否     |
| 读提交   | 不允许   | 可以出现   | 可以出现 | 否     |
| 可重复读 | 不允许   | 不允许     | 不允许   | 否     |
| 序列化   | 不允许   | 不允许     | 不允许   | 是     |



- **READ UNCOMMITTED 【读未提交】**

    - 可读取到未提交数据，产生**脏读**【偷听到的数据，还未提交的】

    

- **READ COMMITTED【读提交】**

    - 可读取到提交数据，但未提交数据不可读，产生**不可重复读**，即可读取到多个提交数据，导致每次读取数据不一致

    

- **REPEATABLE READ 【可重复读】**

    - 可重复读，多次读取数据都一致，产生**幻读**，即读取过程中，即使有其它提交的事务修改数据，仍只能读取到未修改前的旧数据。此为MySQL默认设置

    

- **SERIALIZABLE 【序列化】**
    - 可串行化，未提交的读事务阻塞写事务（加读锁，但不阻塞读事务），或者未提交的写事务阻塞读和写事务（加写锁，其它事务的读，写都不可以执行）。会导致**并发性能差**



**查询事务隔离级别：**

服务器变量tx_isolation(MySQL8.0改名为transaction_isolation)指定，默认为REPEATABLEREAD，可在GLOBAL和SESSION级进行设置

```sql
#MySQL 8.0 之前
select @@tx_isolation;

#MySQL 8.0
select @@transaction_isolation;
```



**修改指定隔离级别：**

```sql
 set transaction_isolation='READ UNCOMMITTED'；
```





### 12. MySQL日志



- **事务日志：**

    - 优化

        - 1 默认值，日志缓冲区将写入日志文件，事务执行完后刷新到磁盘
        - 0 提交时，没有写入磁盘的操作；而是每秒将日志缓冲区的提交的事务刷新到磁盘
        - 2每次提交后都会写入OS的缓冲区，但是每秒才会写入磁盘一次

        

- **通用日志:** general log：记录对数据库的通用操作，包括:错误的SQL语句



- **错误日志**：error log

    - 查询错误日志存放位置

        - ```sql
            SHOW GLOBAL VARIABLES LIKE 'log_error' ;
            ```



- **慢查询日志:** slow query log ：记录执行查询时长超出指定时长的操作



- **二进制日志：**binary log【备份】

    - 记录导致数据发生改变或者潜在导致数据改变的SQL语句

    - 记录已提交的日志

    - 不依赖于存储类型

        - 开启二进制日志

            - ```sh
                slow_query_log=1
                ```

                

- 事务日志和二进制日志的区别：
    - 事务日志在线，二进制离线
    - 事务日志记录事务执行的过程，包括提交和为未提交，二进制只记录提交
    - 事务日志只支持innodb，而二进制支持myisam和innodb



- **中继日志：** reley  log 在主从复制架构中，从服务器用于保存从主服务器的二进制日志中读取的事件 



### 14.  MySQL的备份方式

- 工具一：MySQLdump

- 工具二：xtrabackup
- 备份的方式：冷备、温备、热备
- 按照备份的数据又分为：完全备份、增量备份、差异备份
- 备份的对象
    - 数据
    - 配置文件
    - os相关的配置文件
    - 复制相关的配置
    - 二进制文件




### 15. MySQL主从复制原理

- **两个角色**

    - master

    - slave

        

- **三个线程**
    - **主节点**
        - dump 线程：为每个slave的I/O 线程，启动一个dump线程，用于向其发送binary log events
    - **从节点**
        - I/O 线程：向master发送请求二进制日志事件，并保存在中继日志里面
        - SQL 线程：从中继日志读取事件，在本地完成重放



**具体原理：**

MySQL会将数据的改变记录在二进制日志binlog里面，所以当主节点的数据改变会将其写入到二进制日志中

然后从节点会在一定的时间内对主节点的二进制日志进程探测，看主节点的数据是否发生变化，如果发生变化则开启一个I/O线程请求主节点的二进制日志事件

同时主节点为每一个I/O线程开启一个dump线程，用于向其发送二进制事件，并保存在从节点的中继日志中，而从节点则开启SQL线程从中继日志中读取二进制日志，在本地存放，达到主从数据一致。最后I/O和SQL线程进入休眠状态。

![image-20230206112400398](C:\Users\14529\AppData\Roaming\Typora\typora-user-images\image-20230206112400398.png)



### 16. MySQL主从复制不一致

MySQL主服务宕机以后数据可能会丢失，从库只有一个SQL线程，主库写压力大，复制可能会延迟。



**解决办法：**

- 可以用半同步复制解决数据丢失的问题
- 用并行复制解决从库复制延迟的问题





### 17. 解决MySQL主从复制压力的方法

第一种：级联复制：将主库的数据同步到级联库，然后级联库把自己的数据同步都从库，以达到减少主库的压力



半同步复制：MySQL默认的主从复制是异步复制，异步复制可以提供最佳的性能，

异步复制就是：当主节点收到客户端提交的事务时，主库把二进制日志发送给从节点，就立刻响应客户端，而不去验证从节点是否把二进制文件保存在本地的中继日志文件内，这就意味着当主节点或者从从节点发生故障时，从节点无法接收到主节点的二进制文件，导致主从数据不一致。

所以需要开启半同步复制，半同步复制就是主节点在客户端提交事务时，把二进制文件发送给从节点，并不会立刻响应客户端，而是等到收到从节点发送过来的从节点数据同步成功后的信息才响应客户端。





### 18. MySQL主从复制的方式

两种，一种是半同步复制和异步复制，半同步复制又分为 after-commit和after-sync

异步复制：即主节点执行完客户端提交的事务后立刻将结果返回给客户端并不关心从节点是否收到。

半同步复制：MySQL默认的就是半同步复制，半同步复制即，客户端提交事务时主节点执行完事务，并不会立刻响应客户端，而是等到从节点收到binlog并写入到自己的relaylog里面，最后收到从节点的ACK响应后，才返回客户端。

- after-commit：主库写入事务到[binlog](https://so.csdn.net/so/search?q=binlog&spm=1001.2101.3001.7020)以及同步从库，sync binlog,并且提交事务到存储引擎，在提交之后主库等待从库接受到事务的确认，在接受到确认之后，源端返回提交完成到客户端。
- after-sync：也可以叫增强半同步复制，或者叫无损复制，主库写入事务到binlog以及同步从库并且sync binlog to disk，主库同步后等待从库接受到事务的确认，在等到从库的确认之后，主库提交事务到存储引擎并且返回客户端





### 19. 判断MySQL主从延迟的方法

可以通过show slave status 查看

比如 seconds_behind_master的值来判定 若是null，则是io线程或者是sql线程出现问题

若是为0 则是没有问题





### 20. MySQL主从延迟产生的原因和解决方法

- 原因
    - 主库的并发连接数较高，产生的DDL数量超过了从节点的sql线程的承受范围
    - 网络抖动
    - 从库的大型query语句产生了锁等待



- 解决方法

    - 架构方面
        - 采用一主多从，读写分离，分担主节点的压力
        - 不同也业务的MySQL放在不同的物理主机上

    

    - MySQL主从同步加速
        - sync_binlog在从节点设置为0
        - -log-slave-updates 从主节点接收到的跟新不写入二进制日志
        - 直接禁用从节点的binglog





### 21. MySQL忘记密码怎么找回

- 在配置文件上添加上skip_grant_tables ,重启MySQL

- 使用MySQL -uroot  -p  进入

- 使用update修改密码

    





### 22. MySQL性能优化



- 开启缓存查询
- 使用explain判断select查询，是否存在查询语句和表结构瓶颈
- 为搜索字段建索引
- 对限定范围取值的字段，推荐使用ENUM而不是VARCHAR
- 垂直分表
- 使用innodb





### 23. 如何加强MySQL的安全

- 定期备份数据库

- 限制远程访问

- 移除test数据库。【默认匿名用户可以访问test数据库】

- 移除匿名账户和废弃账户

- 禁用local infile 【会降低攻击者通过SQL注入漏洞器读取敏感文件的能力】

- 限制MySQL用户的权限

- 移除和禁用.MySQL.history文件【myslq的历史命令记录文件】

    



### 24. MySQL是什么数据库，有什么特点？

- MySQL是关系型数据库，他的数据是存储在而未被里面，即存储数据前需要创建有关联的表才可，且关系型数据库的表和表之间的字段存在垂直或者平级的关系。且关系型数据库的数据是存储在磁盘里

- 另一种数据库是非关系型数据库如;redis ，非关系型数据库的数据类似于键值对的形式存储，且非关系型数据库的数据是存储在内存中的

    



### 25. 网站打开慢，请给出排查方法

- 查询操作系统是否负载过高
- 登录MySQL使用show processlist 查询那些sql的语句占用时间
- 使用explain查看消耗时间过长的sql语句是否走了索引，若是没有创建索引



### 26. 误执行drop数据，如何通过xtrabackup恢复?

- 关闭mysql
- 移除MySQL的data文件和目录
- 将备份的数据恢复到MySQL的data目录下
- 启动





### 27. 当mysql数据库cpu飙升时怎么处理？

先操作系统命令top命令观察是不是mysqld占用导致的 如果不是则找出对应的进程，并进行相关操作

如果是

先进入MySQL 用 show  processlist，查看里面的session情况  是不是有消耗资源的sql在运行

然后使用kill 掉这些线程 观察cpu使用率是否下降

也有可能时大量的session进来导致的，后续可以限制最大连接数
